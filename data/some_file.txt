#load "amber_types.jai";
#load "amber_core.jai";
#load "amber_math.jai";
#load "amber_unicode.jai";
#load "amber_platform.jai";
#load "amber_gl.jai";
#load "amber_draw.jai";
#load "amber_font.jai";
#load "amber_buffer.jai";
#load "amber_text_layout.jai";

running : bool;
CURSOR_ROUNDING :: 2.0;

visualize_buffer :: (font : *Font, position : Vec2f, buffer : *Buffer, height : u32)
{
	prev_texture := draw_get_texture ();
	defer draw_set_texture (prev_texture);
	prev_shader := draw_set_shader (glyph_shader);
	defer draw_set_shader (prev_shader);

	page := load_page (font, height);
	pen := vec2f (round (position.x), round (position.y));
	for i : 0..buffer.allocated - 1
	{
		if i >= buffer.offset && i < buffer.offset + buffer.gap
		{
			rect := xywhf (
				pen.x,
				pen.y + page.ascent - page.descent,
				xx page.space_advance,
				xx (page.ascent - page.descent));
			draw_set_texture (0);
			draw_rect (rect, rgba (150, 150, 150), 1);
			pen.x += page.space_advance;
			
			continue;
		}
		
		codepoint := buffer.data[i];
		if codepoint ==
		{
		case #char "\n";
			codepoint = 0x27f5;
		case #char "\t";
			codepoint = 0x2192;
		case #char " ";
			codepoint = 0xb7;
		}
		glyph := load_glyph (page, codepoint);
		
		on_cursor := false;
		for icur : 0..buffer.other_cursors.count
		{
			cur := get_cursor (buffer, icur);
			offset := cur.offset;
			if offset >= buffer.offset then offset += buffer.gap;
			if i == offset
			{
				rect := xywhf (
					pen.x,
					pen.y,
					xx glyph.advance,
					xx (page.ascent - page.descent));
				draw_set_texture (0);
				draw_rect (rect, RGBA_WHITE, 1);
				on_cursor = true;
			}
		}
		
		glyph_rect := xywhf (
			pen.x + glyph.bitmap_bearing_x,
			pen.y - glyph.bitmap_bearing_y + page.ascent,
			xx glyph.bitmap_width,
			xx glyph.bitmap_height);
		draw_set_texture (glyph.atlas_texture);
		draw_rect (glyph_rect, (ifx on_cursor then RGBA_BLACK else RGBA_WHITE), uv_rect = glyph.uv_rect);
		rect := xywhf (
			pen.x,
			pen.y + page.ascent - page.descent,
			xx glyph.advance,
			xx (page.ascent - page.descent));
		draw_set_texture (0);
		draw_rect (rect, RGBA_WHITE, 1);
		pen.x += glyph.advance;
	}
}

draw_buffer :: (font : *Font, position : Vec2f, buffer : *Buffer, height : u32, color : RGBA)
{
	prev_texture := draw_get_texture ();
	defer draw_set_texture (prev_texture);
	prev_shader := draw_set_shader (glyph_shader);
	defer draw_set_shader (prev_shader);
	
	page := load_page (font, height);
	start_position := vec2f (round (position.x), round (position.y));
	pen := start_position;
	for codepoint, i : buffer
	{
		DIMMING :: 10;
		cursor_index := -1;
		for ci : 0..buffer.other_cursors.count
		{
			cursor := get_cursor (buffer, ci);
			if i == cursor.offset
			{
				cursor_index = ci;
				break;
			}
		}
		
		if codepoint == #char "\n"
		{
			if cursor_index >= 0
			{
				draw_set_texture (0);
				draw_rect (xywh (
					pen.x,
					pen.y,
					xx page.space_advance,
					xx (page.ascent - page.descent)),
					dim (color, xx (cursor_index * DIMMING))
				);
			}
			pen.x = start_position.x;
			pen.y += page.ascent - page.descent;
		}
		else if codepoint == #char "\t"
		{
			cursor_rect := xywhf (pen.x, pen.y, 0, xx (page.ascent - page.descent));
			pen.x += page.space_advance;
			pen.x = start_position.x + snap_up (pen.x - start_position.x, page.space_advance * 4.0);
			cursor_rect.x2 = pen.x;
			if cursor_index >= 0
			{
				draw_set_texture (0);
				draw_rect (cursor_rect, dim (color, xx (cursor_index * DIMMING)));
			}
		}
		else
		{
			glyph := load_glyph (page, codepoint);
			glyph_rect := xywhf (
				pen.x + glyph.bitmap_bearing_x,
				pen.y - glyph.bitmap_bearing_y + page.ascent,
				xx glyph.bitmap_width,
				xx glyph.bitmap_height);
			cursor_rect := xywhf (
				pen.x,
				pen.y,
				xx glyph.advance,
				xx (page.ascent - page.descent)
				);
			if cursor_index >= 0
			{
				draw_set_texture (0);
				draw_rect (cursor_rect, dim (color, xx (cursor_index * DIMMING)));
			}
			draw_set_texture (glyph.atlas_texture);
			draw_rect (glyph_rect, (ifx cursor_index >= 0 then invert (color) else color), uv_rect = glyph.uv_rect);
			pen.x += glyph.advance;
		}
	}
}

draw_text :: (font : *Font, height : u32, position : Vec2f, text : string, color : RGBA)
{
	prev_texture := draw_get_texture ();
	defer draw_set_texture (prev_texture);
	prev_shader := draw_set_shader (glyph_shader);
	defer draw_set_shader (prev_shader);
	
	page := load_page (font, height);
	pen : Vec2f;
	for i : 0..text.count - 1
	{
		codepoint : u32 = text[i];
		if codepoint ==
		{
		case #char "\n";
			pen.x = 0;
			pen.y += page.ascent - page.descent;
		
		case #char "\t";
			pen.x = snap_up (pen.x + page.space_advance, page.space_advance * 4.0);
		
		case;
			glyph := load_glyph (page, codepoint);
			glyph_rect := xywhf (
				pen.x + glyph.bitmap_bearing_x,
				pen.y - glyph.bitmap_bearing_y + page.ascent,
				xx glyph.bitmap_width,
				xx glyph.bitmap_height);
			glyph_rect = move (glyph_rect, round (position.x), round (position.y));
			draw_set_texture (glyph.atlas_texture);
			draw_rect (glyph_rect, color, uv_rect = glyph.uv_rect);
			pen.x += glyph.advance;
		}
	}
}

main :: ()
{
	FONT_NAME :: "fonts/jetbrainsmono/JetBrainsMono-Regular.ttf";
	
	platform_init_window_and_gl ();
	draw_init ();
	font_init ();
	font : Font;
	if !load_font_from_file (*font, FONT_NAME)
	{
		platform_open_error_box ("Could not load font '%'.", FONT_NAME);
		return;
	}
	str := platform_read_entire_file ("some_file.txt", HEAP);
	buffer : Buffer;
	start := platform_get_time ();
	init_buffer (*buffer, str.count * 2);
	for i : 0..str.count - 1
		insert_at_cursor (*buffer, xx str[i], WRITE_HEAD);
	end := platform_get_time ();
	println ("Filling buffer took % milliseconds.", (end - start) * 1000);
	start = end;
	move_cursor_to_beginning (*buffer, WRITE_HEAD);
	end = platform_get_time ();
	println ("Moving the cursor took % milliseconds.", (end - start) * 1000);
	layout : Text_Layout;
	layout.buffer = *buffer;
	layout.font = *font;
	layout.font_height = 16;
	init_array (*layout.rects, buffer.allocated, HEAP);
	init_array (*layout.wrapped_lines, buffer.lines.allocated, HEAP);

	cursor_index := 0;
	draw_set_clear_color (rgba (10, 10, 10, 255));
	running = true;
	page := load_page (*font, 16);
	while running
	{
		frame_start := platform_get_time ();
		modified := false;
		reset_temporary_storage ();
		events := platform_poll_window_events ();
		for events
		{
			if it.kind ==
			{
			case .TEXT_INPUT;
				insert_at_cursor (*buffer, it.codepoint, ALL_CURSORS);
				modified = true;
				
			case .KEY_PRESS; #through;
			case .KEY_REPEAT;
				if it.key_code ==
				{
				case .ESCAPE;
					clear_cursors (*buffer);
				
				case .TAB;
					insert_at_cursor (*buffer, #char "\t", ALL_CURSORS);
					modified = true;
				
				case .RETURN;
					insert_at_cursor (*buffer, #char "\n", ALL_CURSORS);
					modified = true;
				
				case .LEFT;
					if it.mods == Mods.CONTROL
						skip_word_backward (*buffer, true, ALL_CURSORS);
					else
						move_cursor_backward (*buffer, ALL_CURSORS);
				
				case .RIGHT;
					if it.mods == Mods.CONTROL
						skip_word_forward (*buffer, true, ALL_CURSORS);
					else
						move_cursor_forward (*buffer, ALL_CURSORS);
				
				case .UP;
					if it.mods == Mods.SHIFT | .ALT
						add_cursor_on_previous_line (*buffer, ALL_CURSORS);
					else if it.mods == Mods.CONTROL
						layout.base_line -= 1;
					else
						move_cursor_to_previous_line (*buffer, ALL_CURSORS);
					
				case .DOWN;
					if it.mods == Mods.SHIFT | .ALT
						add_cursor_on_next_line (*buffer, ALL_CURSORS);
					else if it.mods == Mods.CONTROL
						layout.base_line += 1;
					else
						move_cursor_to_next_line (*buffer, ALL_CURSORS);
				}
			case .MOUSE_PRESS;
				if it.mouse_button == .LEFT && contains (layout.area, it.mouse_position)
				{
					offset := get_closest_character (*layout, it.mouse_position);
					clear_cursors (*buffer);
					move_cursor_to_offset (*buffer, offset, WRITE_HEAD);
				}
			}
		}

		wave := cos (cast (f32) platform_get_time () * 0.2) * 0.5 + 0.5;
		viewport := platform_get_viewport_size ();
		area := rectf (0, 0, xx viewport.width, xx viewport.height);
		if area != layout.area || modified
		{
			layout.area = area;
			layout_text (*layout);
		}
		layout.base_line = clamp (layout.base_line, 0, layout.wrapped_lines.count - 1);
		
		draw_begin ();
		//draw_buffer (*font, vec2f (0, 0), *buffer, 16, RGBA_WHITE);
		//visualize_buffer (*font, vec2f (0, 0), *buffer, 16);
		draw_text_layout (*layout, RGBA_WHITE);
		draw_rect (xywhf (0, xx (viewport.height - page.ascent + page.descent), xx viewport.width, xx (page.ascent - page.descent)), RGBA_WHITE);
		draw_text (
			*font,
			16,
			vec2f (0, xx (viewport.height - (page.ascent - page.descent))),
			fstring (TEMP, "Ln %, Col % ~ % line(s)", buffer.line_index + 1, buffer.column_index + 1, buffer.lines.count),
			RGBA_BLACK
		);
		draw_flush ();
		platform_swap_window_buffers ();
		frame_end := platform_get_time ();
		println ("Frame took % milliseconds.", (frame_end - frame_start) * 1000);
		platform_sleep_milliseconds (16);
	}
}
